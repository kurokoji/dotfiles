[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['context_filetype.vim', 'denops.vim', 'pum.vim']
on_event = ['InsertEnter', 'CursorHold']
# hook_add {{{
hook_add = '''
'''
# }}}
# hook_source {{{
hook_source = '''
call ddc#custom#patch_global({
      \   'sources': ['neosnippet', 'vim-lsp', 'around', 'file'],
      \   'sourceOptions': {
      \     '_': {
      \       'matchers': ['matcher_head'],
      \       'sorters': ['sorter_rank']
      \     },
      \     'around': {
      \       'mark': 'A',
      \     },
      \     'vim-lsp': {
      \       'matchers': ['matcher_head'],
      \       'mark': 'LSP',
      \       'forceCompletionPattern': '\.\w*|:\w*|->\w*'
      \     },
      \     'file': {
      \       'mark': 'F',
      \       'isVolatile': v:true,
      \       'forceCompletionPattern': '\S/\S*',
      \     },
      \     'skkeleton': {
      \       'mark': 'skkeleton',
      \       'matchers': ['skkeleton'],
      \       'sorters': [],
      \       'minAutoCompleteLength': 2,
      \     },
      \     'neosnippet': {
      \       'mark': 'NSnip'
      \     },
      \     'shell-histroy': {
      \       'mark': 'shell'
      \     },
      \   },
      \   'sourceParams': {
      \     'around': {
      \       'maxSize': 500,
      \     }
      \   }
      \ })

call ddc#custom#patch_global('autoCompleteEvents', [
    \ 'InsertEnter', 'TextChangedI', 'TextChangedP',
    \ 'CmdlineEnter', 'CmdlineChanged',
    \ ])
call ddc#custom#patch_global('completionMenu', 'pum.vim')

" For insert mode completion
inoremap <silent><expr> <C-n>
      \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
      \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
      \ '<C-n>' : ddc#manual_complete()
inoremap <silent><expr> <C-p>
      \ pum#visible() ? '<Cmd>call pum#map#insert_relative(-1)<CR>' :
      \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
      \ '<C-p>' : ddc#manual_complete()
" inoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
" inoremap <C-e>   <Cmd>call pum#map#cancel()<CR>
inoremap <silent><expr> <C-l>   ddc#map#extend()
inoremap <silent><expr> <C-x><C-f> ddc#manual_complete('path')

" For command line mode completion
cnoremap <expr> <Tab>
\ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
\ exists('b:ddc_cmdline_completion') ?
\ ddc#manual_complete() : nr2char(&wildcharm)
cnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
cnoremap <C-c>   <Cmd>call pum#map#cancel()<CR>
cnoremap <C-o>   <Cmd>call pum#map#confirm()<CR>

"call ddc#custom#patch_filetype(['deol'], {
"      \   'keywordPattern': '[0-9a-zA-Z_./-]',
"      \   'sources': ['skkeleton', 'shell-history'],
"      \ })

call ddc#enable()
'''
# }}}
# hook_add {{{
hook_add = '''
nnoremap :       <Cmd>call CommandlinePre(':')<CR>:
nnoremap ?       <Cmd>call CommandlinePre('/')<CR>?

function! CommandlinePre(mode) abort
  " Note: It disables default command line completion!
  set wildchar=<C-t>
  set wildcharm=<C-t>
  cnoremap <expr><buffer> <Tab>
  \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
  \ exists('b:ddc_cmdline_completion') ? ddc#manual_complete() : "\<C-t>"
  " Overwrite sources
  if !exists('b:prev_buffer_config')
    let b:prev_buffer_config = ddc#custom#get_buffer()
  endif
  if a:mode ==# ':'
    call ddc#custom#patch_buffer('cmdlineSources',
            \ ['cmdline-history', 'cmdline', 'around'])
    call ddc#custom#patch_buffer('keywordPattern', '[0-9a-zA-Z_:#]*')
  else
    call ddc#custom#patch_buffer('cmdlineSources',
            \ ['around', 'line'])
  endif
  autocmd MyAutoCmd User DDCCmdlineLeave ++once call CommandlinePost()
  autocmd MyAutoCmd InsertEnter <buffer> ++once call CommandlinePost()
  call ddc#enable_cmdline_completion()
endfunction

function! CommandlinePost() abort
  silent! cunmap <buffer> <Tab>
  " Restore sources
  if exists('b:prev_buffer_config')
    call ddc#custom#set_buffer(b:prev_buffer_config)
    unlet b:prev_buffer_config
  else
    call ddc#custom#set_buffer({})
  endif
  set wildcharm=<Tab>
endfunction
'''
# }}}

[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

[[plugins]]
repo = 'shun/ddc-vim-lsp'
on_source = 'ddc.vim'
depends = ['vim-lsp']

[[plugins]]
repo = 'Shougo/pum.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/neosnippet.vim'
on_source = 'ddc.vim'
depends = ['neosnippet-snippets']
# hook_add {{{
hook_add = '''
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)
'''
# }}}

[[plugins]]
repo = 'kurokoji/neosnippet-snippets'

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = ['vim', 'toml', 'markdown']
depends = 'ddc.vim'
# hook_source {{{
hook_source = '''
call ddc#custom#patch_filetype(
      \ ['vim'], 'sources', ['neosnippet', 'necovim', 'around', 'file']
      \ )
'''
# }}}

[[plugins]]
repo = 'vim-skk/skkeleton'
on_source = 'ddc.vim'
# hook_add {{{
hook_add = '''
function! s:skkeleton_init() abort
  call skkeleton#config({
        \ 'eggLikeNewline': v:true,
        \ 'globalJisyo': '~/.skk/SKK-JISYO.L',
        \ })
endfunction

function! s:skkeleton_pre() abort
  " Overwrite sources
  let s:prev_buffer_config = ddc#custom#get_buffer()
  call ddc#custom#patch_buffer('sources', ['skkeleton'])
endfunction

function! s:skkeleton_post() abort
  " Restore sources
  call ddc#custom#set_buffer(s:prev_buffer_config)
endfunction


autocmd User skkeleton-initialize-pre call s:skkeleton_init()
autocmd User skkeleton-enable-pre call s:skkeleton_pre()
autocmd User skkeleton-disable-pre call s:skkeleton_post()

imap <C-j> <Plug>(skkeleton-toggle)
cmap <C-j> <Plug>(skkeleton-toggle)
'''
# }}}
# hook_source {{{
hook_source = '''
'''
# }}}
